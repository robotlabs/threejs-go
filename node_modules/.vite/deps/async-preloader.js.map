{
  "version": 3,
  "sources": ["../../fontfaceobserver-es/dist/fontfaceobserver.esm.js", "../../async-preloader/src/types.ts", "../../async-preloader/src/index.ts"],
  "sourcesContent": ["/* Font Face Observer v3.3.1 - Â© Bram Stein - Damien Seguin. License: BSD-3-Clause */\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nvar styles = {\n  maxWidth: \"none\",\n  display: \"inline-block\",\n  position: \"absolute\",\n  height: \"100%\",\n  width: \"100%\",\n  overflow: \"scroll\",\n  fontSize: \"16px\"\n};\nvar collapsibleInnerStyles = {\n  display: \"inline-block\",\n  height: \"200%\",\n  width: \"200%\",\n  fontSize: \"16px\",\n  maxWidth: \"none\"\n};\nvar fontStyle = {\n  maxWidth: \"none\",\n  minWidth: \"20px\",\n  minHeight: \"20px\",\n  display: \"inline-block\",\n  overflow: \"hidden\",\n  position: \"absolute\",\n  width: \"auto\",\n  margin: \"0\",\n  padding: \"0\",\n  top: \"-999px\",\n  whiteSpace: \"nowrap\",\n  fontSynthesis: \"none\"\n};\n\nvar Ruler =\n/*#__PURE__*/\nfunction () {\n  /**\n   *\n   * @param {string} text\n   */\n  function Ruler(text) {\n    _classCallCheck(this, Ruler);\n\n    this.element = document.createElement(\"div\");\n    this.element.setAttribute(\"aria-hidden\", \"true\");\n    this.element.appendChild(document.createTextNode(text));\n    this.collapsible = document.createElement(\"span\");\n    this.expandable = document.createElement(\"span\");\n    this.collapsibleInner = document.createElement(\"span\");\n    this.expandableInner = document.createElement(\"span\");\n    this.lastOffsetWidth = -1;\n    Object.assign(this.collapsible.style, styles);\n    Object.assign(this.expandable.style, styles);\n    Object.assign(this.expandableInner.style, styles);\n    Object.assign(this.collapsibleInner.style, collapsibleInnerStyles);\n    this.collapsible.appendChild(this.collapsibleInner);\n    this.expandable.appendChild(this.expandableInner);\n    this.element.appendChild(this.collapsible);\n    this.element.appendChild(this.expandable);\n  }\n  /**\n   * @return {Element}\n   */\n\n\n  _createClass(Ruler, [{\n    key: \"getElement\",\n    value: function getElement() {\n      return this.element;\n    }\n    /**\n     * @param {string} font\n     */\n\n  }, {\n    key: \"setFont\",\n    value: function setFont(font) {\n      Object.assign(this.element.style, _objectSpread({}, fontStyle, {\n        font: font\n      }));\n    }\n    /**\n     * @return {number}\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.element.offsetWidth;\n    }\n    /**\n     * @param {string} width\n     */\n\n  }, {\n    key: \"setWidth\",\n    value: function setWidth(width) {\n      this.element.style.width = width + \"px\";\n    }\n    /**\n     * @private\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var offsetWidth = this.getWidth();\n      var width = offsetWidth + 100;\n      this.expandableInner.style.width = width + \"px\";\n      this.expandable.scrollLeft = width;\n      this.collapsible.scrollLeft = this.collapsible.scrollWidth + 100;\n\n      if (this.lastOffsetWidth !== offsetWidth) {\n        this.lastOffsetWidth = offsetWidth;\n        return true;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * @private\n     * @param {function(number)} callback\n     */\n\n  }, {\n    key: \"onScroll\",\n    value: function onScroll(callback) {\n      if (this.reset() && this.element.parentNode !== null) {\n        callback(this.lastOffsetWidth);\n      }\n    }\n    /**\n     * @param {function(number)} callback\n     */\n\n  }, {\n    key: \"onResize\",\n    value: function onResize(callback) {\n      var that = this;\n\n      function onScroll() {\n        that.onScroll(callback);\n      }\n\n      this.collapsible.addEventListener(\"scroll\", onScroll);\n      this.expandable.addEventListener(\"scroll\", onScroll);\n      this.reset();\n    }\n  }]);\n\n  return Ruler;\n}();\n\nfunction onReady(callback) {\n  document.body ? callback() : document.addEventListener ? document.addEventListener(\"DOMContentLoaded\", function c() {\n    document.removeEventListener(\"DOMContentLoaded\", c);\n    callback();\n  }) : document.attachEvent(\"onreadystatechange\", function k() {\n    if (\"interactive\" == document.readyState || \"complete\" == document.readyState) document.detachEvent(\"onreadystatechange\", k), callback();\n  });\n}\n\n/** Class for FontFaceObserver. */\n\nvar FontFaceObserver =\n/*#__PURE__*/\nfunction () {\n  _createClass(FontFaceObserver, null, [{\n    key: \"getUserAgent\",\n\n    /**\n     * @type {null|boolean}\n     */\n\n    /**\n     * @type {null|boolean}\n     */\n\n    /**\n     * @type {null|boolean}\n     */\n\n    /**\n     * @type {null|boolean}\n     */\n\n    /**\n     * @type {number}\n     */\n\n    /**\n     * @return {string}\n     */\n    value: function getUserAgent() {\n      return window.navigator.userAgent;\n    }\n    /**\n     * @return {string}\n     */\n\n  }, {\n    key: \"getNavigatorVendor\",\n    value: function getNavigatorVendor() {\n      return window.navigator.vendor;\n    }\n    /**\n     * Returns true if this browser is WebKit and it has the fallback bug which is\n     * present in WebKit 536.11 and earlier.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"hasWebKitFallbackBug\",\n    value: function hasWebKitFallbackBug() {\n      if (FontFaceObserver.HAS_WEBKIT_FALLBACK_BUG === null) {\n        var match = /AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))/.exec(FontFaceObserver.getUserAgent());\n        FontFaceObserver.HAS_WEBKIT_FALLBACK_BUG = !!match && (parseInt(match[1], 10) < 536 || parseInt(match[1], 10) === 536 && parseInt(match[2], 10) <= 11);\n      }\n\n      return FontFaceObserver.HAS_WEBKIT_FALLBACK_BUG;\n    }\n    /**\n     * Returns true if the browser has the Safari 10 bugs. The native font load\n     * API in Safari 10 has two bugs that cause the document.fonts.load and\n     * FontFace.prototype.load methods to return promises that don't reliably get\n     * settled.\n     *\n     * The bugs are described in more detail here:\n     *  - https://bugs.webkit.org/show_bug.cgi?id=165037\n     *  - https://bugs.webkit.org/show_bug.cgi?id=164902\n     *\n     * If the browser is made by Apple, and has native font loading support, it is\n     * potentially affected. But the API was fixed around AppleWebKit version 603,\n     * so any newer versions that that does not contain the bug.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"hasSafari10Bug\",\n    value: function hasSafari10Bug() {\n      if (FontFaceObserver.HAS_SAFARI_10_BUG === null) {\n        if (FontFaceObserver.supportsNativeFontLoading() && /Apple/.test(FontFaceObserver.getNavigatorVendor())) {\n          var match = /AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))(?:\\.([0-9]+))/.exec(FontFaceObserver.getUserAgent());\n          FontFaceObserver.HAS_SAFARI_10_BUG = !!match && parseInt(match[1], 10) < 603;\n        } else {\n          FontFaceObserver.HAS_SAFARI_10_BUG = false;\n        }\n      }\n\n      return FontFaceObserver.HAS_SAFARI_10_BUG;\n    }\n    /**\n     * Returns true if the browser supports the native font loading API.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"supportsNativeFontLoading\",\n    value: function supportsNativeFontLoading() {\n      if (FontFaceObserver.SUPPORTS_NATIVE_FONT_LOADING === null) {\n        FontFaceObserver.SUPPORTS_NATIVE_FONT_LOADING = !!document[\"fonts\"];\n      }\n\n      return FontFaceObserver.SUPPORTS_NATIVE_FONT_LOADING;\n    }\n    /**\n     * Returns true if the browser supports font-style in the font short-hand\n     * syntax.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"supportStretch\",\n    value: function supportStretch() {\n      if (FontFaceObserver.SUPPORTS_STRETCH === null) {\n        var div = document.createElement(\"div\");\n\n        try {\n          div.style.font = \"condensed 100px sans-serif\";\n        } catch (e) {}\n\n        FontFaceObserver.SUPPORTS_STRETCH = div.style.font !== \"\";\n      }\n\n      return FontFaceObserver.SUPPORTS_STRETCH;\n    }\n    /**\n     * @typedef {Object} Descriptors\n     * @property {string|undefined} style\n     * @property {string|undefined} weight\n     * @property {string|undefined} stretch\n     */\n\n    /**\n     *\n     * @param {string} family font-family name (required)\n     * @param {Descriptors} descriptors an object describing the variation\n     * (optional). The object can contain `weight`, `style`, and `stretch`\n     * properties. If a property is not present it will default to `normal`.\n     */\n\n  }]);\n\n  function FontFaceObserver(family) {\n    var descriptors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, FontFaceObserver);\n\n    this.family = family;\n    this.style = descriptors.style || \"normal\";\n    this.weight = descriptors.weight || \"normal\";\n    this.stretch = descriptors.stretch || \"normal\";\n    return this;\n  }\n  /**\n   * @param {string=} text Optional test string to use for detecting if a font\n   * is available.\n   * @param {number=} timeout Optional timeout for giving up on font load\n   * detection and rejecting the promise (defaults to 3 seconds).\n   * @return {Promise.<FontFaceObserver>}\n   */\n\n\n  _createClass(FontFaceObserver, [{\n    key: \"load\",\n    value: function load(text, timeout) {\n      var that = this;\n      var testString = text || \"BESbswy\";\n      var timeoutId = 0;\n      var timeoutValue = timeout || FontFaceObserver.DEFAULT_TIMEOUT;\n      var start = that.getTime();\n      return new Promise(function (resolve, reject) {\n        if (FontFaceObserver.supportsNativeFontLoading() && !FontFaceObserver.hasSafari10Bug()) {\n          var loader = new Promise(function (resolve, reject) {\n            var check = function check() {\n              var now = that.getTime();\n\n              if (now - start >= timeoutValue) {\n                reject(new Error(\"\" + timeoutValue + \"ms timeout exceeded\"));\n              } else {\n                document.fonts.load(that.getStyle('\"' + that[\"family\"] + '\"'), testString).then(function (fonts) {\n                  if (fonts.length >= 1) {\n                    resolve();\n                  } else {\n                    setTimeout(check, 25);\n                  }\n                }, reject);\n              }\n            };\n\n            check();\n          });\n          var timer = new Promise(function (resolve, reject) {\n            timeoutId = setTimeout(function () {\n              reject(new Error(\"\" + timeoutValue + \"ms timeout exceeded\"));\n            }, timeoutValue);\n          });\n          Promise.race([timer, loader]).then(function () {\n            clearTimeout(timeoutId);\n            resolve(that);\n          }, reject);\n        } else {\n          onReady(function () {\n            var rulerA = new Ruler(testString);\n            var rulerB = new Ruler(testString);\n            var rulerC = new Ruler(testString);\n            var widthA = -1;\n            var widthB = -1;\n            var widthC = -1;\n            var fallbackWidthA = -1;\n            var fallbackWidthB = -1;\n            var fallbackWidthC = -1;\n            var container = document.createElement(\"div\");\n            /**\n             * @private\n             */\n\n            function removeContainer() {\n              if (container.parentNode !== null) {\n                container.parentNode.removeChild(container);\n              }\n            }\n            /**\n             * @private\n             *\n             * If metric compatible fonts are detected, one of the widths will be\n             * -1. This is because a metric compatible font won't trigger a scroll\n             * event. We work around this by considering a font loaded if at least\n             * two of the widths are the same. Because we have three widths, this\n             * still prevents false positives.\n             *\n             * Cases:\n             * 1) Font loads: both a, b and c are called and have the same value.\n             * 2) Font fails to load: resize callback is never called and timeout\n             *    happens.\n             * 3) WebKit bug: both a, b and c are called and have the same value,\n             *    but the values are equal to one of the last resort fonts, we\n             *    ignore this and continue waiting until we get new values (or a\n             *    timeout).\n             */\n\n\n            function check() {\n              if (widthA != -1 && widthB != -1 || widthA != -1 && widthC != -1 || widthB != -1 && widthC != -1) {\n                if (widthA == widthB || widthA == widthC || widthB == widthC) {\n                  // All values are the same, so the browser has most likely\n                  // loaded the web font\n                  if (FontFaceObserver.hasWebKitFallbackBug()) {\n                    // Except if the browser has the WebKit fallback bug, in which\n                    // case we check to see if all values are set to one of the\n                    // last resort fonts.\n                    if (widthA == fallbackWidthA && widthB == fallbackWidthA && widthC == fallbackWidthA || widthA == fallbackWidthB && widthB == fallbackWidthB && widthC == fallbackWidthB || widthA == fallbackWidthC && widthB == fallbackWidthC && widthC == fallbackWidthC) {\n                      // The width we got matches some of the known last resort\n                      // fonts, so let's assume we're dealing with the last resort\n                      // font.\n                      return;\n                    }\n                  }\n\n                  removeContainer();\n                  clearTimeout(timeoutId);\n                  resolve(that);\n                }\n              }\n            } // This ensures the scroll direction is correct.\n\n\n            container.dir = \"ltr\";\n            rulerA.setFont(that.getStyle(\"sans-serif\"));\n            rulerB.setFont(that.getStyle(\"serif\"));\n            rulerC.setFont(that.getStyle(\"monospace\"));\n            container.appendChild(rulerA.getElement());\n            container.appendChild(rulerB.getElement());\n            container.appendChild(rulerC.getElement());\n            document.body.appendChild(container);\n            fallbackWidthA = rulerA.getWidth();\n            fallbackWidthB = rulerB.getWidth();\n            fallbackWidthC = rulerC.getWidth();\n\n            function checkForTimeout() {\n              var now = that.getTime();\n\n              if (now - start >= timeoutValue) {\n                removeContainer();\n                reject(new Error(\"\" + timeoutValue + \"ms timeout exceeded\"));\n              } else {\n                var hidden = document[\"hidden\"];\n\n                if (hidden === true || hidden === undefined) {\n                  widthA = rulerA.getWidth();\n                  widthB = rulerB.getWidth();\n                  widthC = rulerC.getWidth();\n                  check();\n                }\n\n                timeoutId = setTimeout(checkForTimeout, 50);\n              }\n            }\n\n            checkForTimeout();\n            rulerA.onResize(function (width) {\n              widthA = width;\n              check();\n            });\n            rulerA.setFont(that.getStyle('\"' + that[\"family\"] + '\",sans-serif'));\n            rulerB.onResize(function (width) {\n              widthB = width;\n              check();\n            });\n            rulerB.setFont(that.getStyle('\"' + that[\"family\"] + '\",serif'));\n            rulerC.onResize(function (width) {\n              widthC = width;\n              check();\n            });\n            rulerC.setFont(that.getStyle('\"' + that[\"family\"] + '\",monospace'));\n          });\n        }\n      });\n    }\n    /**\n     * @private\n     *\n     * @param {string} family\n     * @return {string}\n     */\n\n  }, {\n    key: \"getStyle\",\n    value: function getStyle(family) {\n      return [this.style, this.weight, FontFaceObserver.supportStretch() ? this.stretch : \"\", \"100px\", family].join(\" \");\n    }\n    /**\n     * @private\n     *\n     * @return {number}\n     */\n\n  }, {\n    key: \"getTime\",\n    value: function getTime() {\n      return new Date().getTime();\n    }\n  }]);\n\n  return FontFaceObserver;\n}();\n\n_defineProperty(FontFaceObserver, \"Ruler\", Ruler);\n\n_defineProperty(FontFaceObserver, \"HAS_WEBKIT_FALLBACK_BUG\", null);\n\n_defineProperty(FontFaceObserver, \"HAS_SAFARI_10_BUG\", null);\n\n_defineProperty(FontFaceObserver, \"SUPPORTS_STRETCH\", null);\n\n_defineProperty(FontFaceObserver, \"SUPPORTS_NATIVE_FONT_LOADING\", null);\n\n_defineProperty(FontFaceObserver, \"DEFAULT_TIMEOUT\", 3000);\n\nexport default FontFaceObserver;\n", "/**\n * Methods that can be called on a Request (object returned by fetch and that implements the [Body](https://developer.mozilla.org/en-US/docs/Web/API/Response/body) interface)\n */\nexport type BodyMethod = \"arrayBuffer\" | \"blob\" | \"formData\" | \"json\" | \"text\";\n\n/**\n * Types that can be returned by all the {@link BodyMethod}\n */\nexport type BodyResolveValue = ArrayBuffer | Blob | FormData | JSON | string;\n\n/**\n * Types that can be returned by the Xml loader. See the {@link LoadItem.mimeType}.\n */\nexport type LoadedXMLValue = Document | XMLDocument;\n\n/**\n * Types that can be returned by all the loaders.\n */\nexport type LoadedValue =\n  | BodyResolveValue\n  | HTMLImageElement\n  | HTMLVideoElement\n  | HTMLAudioElement\n  | LoadedXMLValue;\n\n/**\n * Main interface representing an object to load. src is the only mandatory key.\n */\nexport interface LoadItem {\n  /**\n   * Input for the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\n   */\n  src: RequestInfo | string;\n  /**\n   * Optional key.\n   *\n   * Used to retrieve the {@link LoadedValue} using `AsyncPreloader.items.get(id)`\n   */\n  id?: unknown;\n  /**\n   * Optional {@link LoaderKey}.\n   *\n   * If none specified, the loader is inferred from the file extension.\n   * Default to `Text` if the extension doesn't match any of the extensions specified in {@link AsyncPreloader.loaders}.\n   *\n   * Note: It needs to be specified for Font and Audio (webm, ogg).\n   */\n  loader?: LoaderKey;\n  /**\n   * Optional `RequestInit` object to pass to the [fetch method](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch).\n   */\n  options?: RequestInit;\n  /**\n   * Font options used by FontFace and FontFaceObserver\n   */\n  fontOptions?: FontOptions;\n  /**\n   * Optional{@link BodyMethod} used to handle the Response.\n   *\n   * Default to `blob` for Image, Video and Audio. See {@link AsyncPreloader.defaultBodyMethod}.\n   */\n  body?: BodyMethod;\n  /**\n   * Optional mimeType used to handle the Response.\n   *\n   * Note: Only used to parse the document in the Xml Loader.\n   */\n  mimeType?: DOMParserSupportedType;\n  /**\n   * Optional disable [image decoding](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode).\n   *\n   * Note: Only used for loadImage.\n   */\n  noDecode?: boolean;\n}\n\n/**\n * Keys used for the {@link AsyncPreloader.loaders}\n */\nexport enum LoaderKey {\n  Json = \"Json\",\n  ArrayBuffer = \"ArrayBuffer\",\n  Blob = \"Blob\",\n  FormData = \"FormData\",\n  Text = \"Text\",\n\n  Image = \"Image\",\n  Video = \"Video\",\n  Audio = \"Audio\",\n  Xml = \"Xml\",\n  Font = \"Font\",\n}\n\n/**\n * Font options used by FontFace and FontFaceObserver\n */\nexport interface FontOptions {\n  /**\n   * [FontFace constructor descriptors](https://developer.mozilla.org/en-US/docs/Web/API/FontFace/FontFace)\n   */\n  descriptors?: FontFaceDescriptors;\n  /**\n   * FontFaceObserver.FontVariant\n   */\n  variant?: FontFaceObserver.FontVariant;\n  /**\n   * Argument for [FontFace.load](https://developer.mozilla.org/en-US/docs/Web/API/FontFace/load)\n   */\n  testString?: string;\n  /**\n   * Argument for [FontFace.load](https://developer.mozilla.org/en-US/docs/Web/API/FontFace/load)\n   */\n  timeout?: number;\n}\n\n/**\n * Values used for the {@link AsyncPreloader.loaders}\n */\nexport interface LoaderValue {\n  /**\n   * {@link LoadItem} with no loader key specified will use the following array to find which loader should be used.\n   */\n  extensions: string[];\n  /**\n   * Optional mimeType used to handle the Response.\n   *\n   * Note: Only used to parse the document in the Xml Loader.\n   */\n  mimeType?: { [key: string]: DOMParserSupportedType };\n  /**\n   * Optional defaultMimeType used to handle the Response.\n   *\n   * Note: Only used to parse the document in the Xml Loader.\n   */\n  defaultMimeType?: DOMParserSupportedType;\n}\n", "import FontFaceObserver from \"fontfaceobserver-es\";\n\nimport {\n  BodyMethod,\n  LoadItem,\n  LoadedValue,\n  LoadedXMLValue,\n  LoaderKey,\n  LoaderValue,\n  FontOptions,\n} from \"./types.js\";\n\nconst isSafari =\n  /^((?!chrome|android).)*safari/i.test(globalThis.navigator?.userAgent) ===\n  true;\n\n/**\n * AsyncPreloader: assets preloader using ES2017 async/await and fetch.\n *\n * It exports an instance of itself as default so you can:\n *\n * ```js\n * import Preloader from \"async-preloader\";\n *\n * await Preloader.loadItems([]);\n * ```\n *\n * to use directly as a singleton or\n *\n * ```js\n * import { AsyncPreloader as Preloader } from \"async-preloader\";\n *\n * const preloader = new Preloader();\n * await preloader.loadItems([]);\n * ```\n * if you need more than one instance.\n */\nclass AsyncPreloader {\n  // Properties\n  /**\n   * Object that contains the loaded items\n   */\n  public items: Map<string, LoadedValue> = new Map();\n\n  /**\n   * Default body method to be called on the Response from fetch if no body option is specified on the LoadItem\n   */\n  public defaultBodyMethod: BodyMethod = \"blob\";\n\n  /**\n   * Default loader to use if no loader key is specified in the {@link LoadItem} or if the extension doesn't match any of the {@link AsyncPreloader.loaders} extensions\n   */\n  public defaultLoader: LoaderKey = LoaderKey.Text;\n\n  /**\n   * Loader types and the extensions they handle\n   *\n   * Allows the omission of the loader key in a {@link LoadItem.loader} for some generic extensions\n   */\n  private static loaders: Map<LoaderKey, LoaderValue> = new Map()\n    .set(LoaderKey.Text, { extensions: [\"txt\"] })\n    .set(LoaderKey.Json, { extensions: [\"json\"] })\n    .set(LoaderKey.Image, { extensions: [\"jpeg\", \"jpg\", \"gif\", \"png\", \"webp\"] })\n    .set(LoaderKey.Video, { extensions: [\"webm\", \"ogg\", \"mp4\"] })\n    .set(LoaderKey.Audio, { extensions: [\"webm\", \"ogg\", \"mp3\", \"wav\", \"flac\"] })\n    .set(LoaderKey.Xml, {\n      extensions: [\"xml\", \"svg\", \"html\"],\n      mimeType: {\n        xml: \"text/xml\",\n        svg: \"image/svg+xml\",\n        html: \"text/html\",\n      },\n      defaultMimeType: \"text/xml\",\n    })\n    .set(LoaderKey.Font, {\n      extensions: [\"woff2\", \"woff\", \"ttf\", \"otf\", \"eot\"],\n    });\n\n  /**\n   * DOMParser instance for the XML loader\n   */\n  private static domParser =\n    typeof DOMParser !== \"undefined\" && new DOMParser();\n\n  // API\n  /**\n   * Load the specified manifest (array of items)\n   *\n   * @param items Items to load\n   * @returns Resolve when all items are loaded, reject for any error\n   */\n  public loadItems = async (\n    items: LoadItem[] | string[],\n  ): Promise<LoadedValue[]> => {\n    return await Promise.all(items.map(this.loadItem));\n  };\n\n  /**\n   * Load a single item\n   *\n   * @param item Item to load\n   * @returns Resolve when item is loaded, reject for any error\n   */\n  public loadItem = async (item: LoadItem | string): Promise<LoadedValue> => {\n    if (typeof item === \"string\") item = { src: item };\n\n    const extension: string = AsyncPreloader.getFileExtension(\n      (item.src as string) || \"\",\n    );\n    const loaderKey: LoaderKey =\n      item.loader || AsyncPreloader.getLoaderKey(extension);\n\n    const loadedItem: LoadedValue = await this[`load` + loaderKey](item);\n\n    this.items.set((item.id || item.src) as string, loadedItem);\n\n    return loadedItem;\n  };\n\n  // Special loaders\n  /**\n   * Load a manifest of items\n   *\n   * @param src Manifest src url\n   * @param key Manifest key in the JSON object containing the array of LoadItem.\n   * @returns\n   */\n  public loadManifest = async (\n    src: string,\n    key = \"items\",\n  ): Promise<LoadedValue[]> => {\n    const loadedManifest: JSON = await this.loadJson({\n      src,\n    });\n    const items: LoadItem[] = AsyncPreloader.getProp(loadedManifest, key);\n\n    return await this.loadItems(items);\n  };\n\n  // Text loaders\n  /**\n   * Load an item and parse the Response as text\n   *\n   * @param item Item to load\n   * @returns Fulfilled value of parsed Response\n   */\n  public loadText = async (item: LoadItem): Promise<string> => {\n    const response: Response = await AsyncPreloader.fetchItem(item);\n    return await response.text();\n  };\n\n  /**\n   * Load an item and parse the Response as json\n   *\n   * @param item Item to load\n   * @returns Fulfilled value of parsed Response\n   */\n  public loadJson = async (item: LoadItem): Promise<JSON> => {\n    const response: Response = await AsyncPreloader.fetchItem(item);\n    return await response.json();\n  };\n\n  /**\n   * Load an item and parse the Response as arrayBuffer\n   *\n   * @param item Item to load\n   * @returns Fulfilled value of parsed Response\n   */\n  public loadArrayBuffer = async (item: LoadItem): Promise<ArrayBuffer> => {\n    const response: Response = await AsyncPreloader.fetchItem(item);\n    return await response.arrayBuffer();\n  };\n\n  /**\n   * Load an item and parse the Response as blob\n   *\n   * @param item Item to load\n   * @returns Fulfilled value of parsed Response\n   */\n  public loadBlob = async (item: LoadItem): Promise<Blob> => {\n    const response: Response = await AsyncPreloader.fetchItem(item);\n    return await response.blob();\n  };\n\n  /**\n   * Load an item and parse the Response as formData\n   *\n   * @param item Item to load\n   * @returns Fulfilled value of parsed Response\n   */\n  public loadFormData = async (item: LoadItem): Promise<FormData> => {\n    const response: Response = await AsyncPreloader.fetchItem(item);\n    return await response.formData();\n  };\n\n  // Custom loaders\n  /**\n   * Load an item in one of the following cases:\n   * - item's \"loader\" option set as \"Image\"\n   * - item's \"src\" option extensions matching the loaders Map\n   * - direct call of the method\n   *\n   * @param item Item to load\n   * @returns Fulfilled value with a decoded HTMLImageElement instance of or a parsed Response according to the \"body\" option. Defaults to a decoded HTMLImageElement.\n   */\n  public loadImage = async (item: LoadItem): Promise<LoadedValue> => {\n    const image = new Image();\n\n    if (item.body) {\n      const response: Response = await AsyncPreloader.fetchItem(item);\n      const data: LoadedValue = await response[item.body]();\n\n      if (item.body !== \"blob\") return data;\n\n      return await new Promise<HTMLImageElement>((resolve, reject) => {\n        image.addEventListener(\"load\", function load() {\n          image.removeEventListener(\"load\", load);\n          resolve(image);\n        });\n        image.addEventListener(\"error\", function error(event) {\n          image.removeEventListener(\"error\", error);\n          reject(event);\n        });\n        image.src = URL.createObjectURL(data as Blob);\n      });\n    }\n\n    image.src = item.src as string;\n\n    if (!item.noDecode) await image.decode();\n\n    return image;\n  };\n\n  /**\n   * Load an item in one of the following cases:\n   * - item's \"loader\" option set as \"Video\"\n   * - item's \"src\" option extensions matching the loaders Map\n   * - direct call of the method\n   *\n   * @param item Item to load\n   * @returns Fulfilled value of parsed Response according to the \"body\" option. Defaults to an HTMLVideoElement with a blob as srcObject or src.\n   */\n  public loadVideo = async (item: LoadItem): Promise<LoadedValue> => {\n    const response: Response = await AsyncPreloader.fetchItem(item);\n    const data: LoadedValue =\n      await response[item.body || this.defaultBodyMethod]();\n\n    if (item.body) return data;\n\n    const video = document.createElement(\"video\");\n\n    return await new Promise<HTMLVideoElement>((resolve, reject) => {\n      video.addEventListener(\"canplaythrough\", function canplaythrough() {\n        video.removeEventListener(\"canplaythrough\", canplaythrough);\n        resolve(video);\n      });\n      video.addEventListener(\"error\", function error(event) {\n        video.removeEventListener(\"error\", error);\n        reject(event);\n      });\n\n      try {\n        if (isSafari) throw \"\";\n        video.srcObject = data as Blob;\n      } catch (error) {\n        video.src = URL.createObjectURL(data as Blob);\n      }\n\n      video.load();\n    });\n  };\n\n  /**\n   * Load an item in one of the following cases:\n   * - item's \"loader\" option set as \"Audio\"\n   * - item's \"src\" option extensions matching the loaders Map\n   * - direct call of the method\n   *\n   * @param item Item to load\n   * @returns Fulfilled value of parsed Response according to the \"body\" option. Defaults to an HTMLAudioElement with a blob as srcObject or src.\n   */\n  public loadAudio = async (item: LoadItem): Promise<LoadedValue> => {\n    const response: Response = await AsyncPreloader.fetchItem(item);\n    const data: LoadedValue =\n      await response[item.body || this.defaultBodyMethod]();\n\n    if (item.body) return data;\n\n    const audio = document.createElement(\"audio\");\n    audio.autoplay = false;\n    audio.preload = \"auto\";\n\n    return await new Promise<HTMLAudioElement>((resolve, reject) => {\n      audio.addEventListener(\"canplaythrough\", function canplaythrough() {\n        audio.removeEventListener(\"canplaythrough\", canplaythrough);\n        resolve(audio);\n      });\n      audio.addEventListener(\"error\", function error(event) {\n        audio.removeEventListener(\"error\", error);\n        reject(event);\n      });\n\n      try {\n        if (isSafari) throw \"\";\n        audio.srcObject = data as Blob;\n      } catch (error) {\n        audio.src = URL.createObjectURL(data as Blob);\n      }\n\n      audio.load();\n    });\n  };\n\n  /**\n   * Load an item in one of the following cases:\n   * - item's \"loader\" option set as \"Xml\"\n   * - item's \"src\" option extensions matching the loaders Map\n   * - direct call of the method\n   *\n   * @param item Item to load (need a mimeType specified or default to \"application/xml\")\n   * @returns Result of Response parsed as a document.\n   */\n  public loadXml = async (item: LoadItem): Promise<LoadedXMLValue> => {\n    if (!item.mimeType) {\n      const extension: string = AsyncPreloader.getFileExtension(\n        item.src as string,\n      );\n      item = {\n        ...item,\n        mimeType: AsyncPreloader.getMimeType(LoaderKey.Xml, extension),\n      };\n    }\n\n    if (!AsyncPreloader.domParser) {\n      throw new Error(\"DomParser is not supported.\");\n    }\n\n    const response: Response = await AsyncPreloader.fetchItem(item);\n    const data: string = await response.text();\n\n    return AsyncPreloader.domParser.parseFromString(data, item.mimeType);\n  };\n\n  /**\n   * Load a font via FontFace or check a font is loaded via FontFaceObserver instance\n   *\n   * @param item Item to load (id correspond to the font family name).\n   * @returns Fulfilled value with FontFace instance or initial id if no src provided.\n   */\n  public loadFont = async (item: LoadItem): Promise<FontFace | string> => {\n    const fontName = (item.id ||\n      AsyncPreloader.getFileName(item.src as string)) as string;\n    const options = (item.fontOptions || {}) as FontOptions;\n\n    if (!item.src) {\n      const font = new FontFaceObserver(\n        fontName,\n        (options.variant as FontFaceObserver.FontVariant) || {},\n      );\n      await font.load(options.testString, options.timeout);\n\n      return fontName;\n    }\n\n    const source =\n      item.body === \"arrayBuffer\"\n        ? await this.loadArrayBuffer({ src: item.src })\n        : `url(${item.src})`;\n\n    const font = new FontFace(fontName, source, options.descriptors);\n\n    return await font.load().then((font) => {\n      document.fonts.add(font);\n      return font;\n    });\n  };\n\n  // Utils\n  /**\n   * Fetch wrapper for LoadItem\n   *\n   * @param item Item to fetch\n   * @returns Fetch response\n   */\n  private static fetchItem(item: LoadItem): Promise<Response> {\n    return fetch(item.src, item.options || {});\n  }\n\n  /**\n   * Get an object property by its path in the form 'a[0].b.c' or ['a', '0', 'b', 'c'].\n   * Similar to [lodash.get](https://lodash.com/docs/4.17.5#get).\n   *\n   * @param object Object with nested properties\n   * @param path Path to the desired property\n   * @returns The returned object property\n   */\n  private static getProp(object: unknown, path: string | string[]) {\n    const p = Array.isArray(path)\n      ? path\n      : path.split(\".\").filter((index) => index.length);\n\n    if (!p.length) return object;\n\n    return AsyncPreloader.getProp(object[p.shift()], p);\n  }\n\n  /**\n   * Get file extension\n   *\n   * @param path\n   * @returns\n   */\n  private static getFileExtension(path: string): string {\n    return (path?.match(/[^\\\\/]\\.([^.\\\\/]+)$/) || [null]).pop();\n  }\n\n  /**\n   * Get file base name\n   *\n   * @param path\n   * @returns\n   */\n  private static getFileBaseName(path: string): string {\n    return path.split(/[\\\\/]/).pop();\n  }\n\n  /**\n   * Get file name\n   *\n   * @param path\n   * @returns\n   */\n  private static getFileName(path: string): string {\n    return (\n      AsyncPreloader.getFileBaseName(path).split(\".\").slice(0, -1).join(\".\") ||\n      path\n    );\n  }\n\n  /**\n   * Retrieve loader key from extension (when the loader option isn't specified in the LoadItem)\n   *\n   * @param extension\n   * @returns\n   */\n  private static getLoaderKey(extension: string): LoaderKey {\n    const loader = Array.from(AsyncPreloader.loaders).find((loader) =>\n      loader[1].extensions.includes(extension),\n    );\n    return loader ? loader[0] : LoaderKey.Text;\n  }\n\n  /**\n   * Retrieve mime type from extension\n   *\n   * @param loaderKey\n   * @param extension\n   * @returns\n   */\n  private static getMimeType(\n    loaderKey: LoaderKey,\n    extension: string,\n  ): DOMParserSupportedType {\n    const loader: LoaderValue = AsyncPreloader.loaders.get(loaderKey);\n    return loader.mimeType[extension] || loader.defaultMimeType;\n  }\n}\n\nexport { AsyncPreloader };\n\nconst AsyncPreloaderInstance = new AsyncPreloader();\nexport default AsyncPreloaderInstance;\n"],
  "mappings": "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",
  "names": ["Ruler", "FontFaceObserver", "resolve", "reject", "check", "LoaderKey", "font", "loader"]
}
