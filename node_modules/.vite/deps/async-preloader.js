import "./chunk-BUSYA2B4.js";

// node_modules/fontfaceobserver-es/dist/fontfaceobserver.esm.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
var styles = {
  maxWidth: "none",
  display: "inline-block",
  position: "absolute",
  height: "100%",
  width: "100%",
  overflow: "scroll",
  fontSize: "16px"
};
var collapsibleInnerStyles = {
  display: "inline-block",
  height: "200%",
  width: "200%",
  fontSize: "16px",
  maxWidth: "none"
};
var fontStyle = {
  maxWidth: "none",
  minWidth: "20px",
  minHeight: "20px",
  display: "inline-block",
  overflow: "hidden",
  position: "absolute",
  width: "auto",
  margin: "0",
  padding: "0",
  top: "-999px",
  whiteSpace: "nowrap",
  fontSynthesis: "none"
};
var Ruler = function() {
  function Ruler2(text) {
    _classCallCheck(this, Ruler2);
    this.element = document.createElement("div");
    this.element.setAttribute("aria-hidden", "true");
    this.element.appendChild(document.createTextNode(text));
    this.collapsible = document.createElement("span");
    this.expandable = document.createElement("span");
    this.collapsibleInner = document.createElement("span");
    this.expandableInner = document.createElement("span");
    this.lastOffsetWidth = -1;
    Object.assign(this.collapsible.style, styles);
    Object.assign(this.expandable.style, styles);
    Object.assign(this.expandableInner.style, styles);
    Object.assign(this.collapsibleInner.style, collapsibleInnerStyles);
    this.collapsible.appendChild(this.collapsibleInner);
    this.expandable.appendChild(this.expandableInner);
    this.element.appendChild(this.collapsible);
    this.element.appendChild(this.expandable);
  }
  _createClass(Ruler2, [{
    key: "getElement",
    value: function getElement() {
      return this.element;
    }
    /**
     * @param {string} font
     */
  }, {
    key: "setFont",
    value: function setFont(font) {
      Object.assign(this.element.style, _objectSpread({}, fontStyle, {
        font
      }));
    }
    /**
     * @return {number}
     */
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.element.offsetWidth;
    }
    /**
     * @param {string} width
     */
  }, {
    key: "setWidth",
    value: function setWidth(width) {
      this.element.style.width = width + "px";
    }
    /**
     * @private
     *
     * @return {boolean}
     */
  }, {
    key: "reset",
    value: function reset() {
      var offsetWidth = this.getWidth();
      var width = offsetWidth + 100;
      this.expandableInner.style.width = width + "px";
      this.expandable.scrollLeft = width;
      this.collapsible.scrollLeft = this.collapsible.scrollWidth + 100;
      if (this.lastOffsetWidth !== offsetWidth) {
        this.lastOffsetWidth = offsetWidth;
        return true;
      } else {
        return false;
      }
    }
    /**
     * @private
     * @param {function(number)} callback
     */
  }, {
    key: "onScroll",
    value: function onScroll(callback) {
      if (this.reset() && this.element.parentNode !== null) {
        callback(this.lastOffsetWidth);
      }
    }
    /**
     * @param {function(number)} callback
     */
  }, {
    key: "onResize",
    value: function onResize(callback) {
      var that = this;
      function onScroll() {
        that.onScroll(callback);
      }
      this.collapsible.addEventListener("scroll", onScroll);
      this.expandable.addEventListener("scroll", onScroll);
      this.reset();
    }
  }]);
  return Ruler2;
}();
function onReady(callback) {
  document.body ? callback() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function c() {
    document.removeEventListener("DOMContentLoaded", c);
    callback();
  }) : document.attachEvent("onreadystatechange", function k() {
    if ("interactive" == document.readyState || "complete" == document.readyState) document.detachEvent("onreadystatechange", k), callback();
  });
}
var FontFaceObserver = function() {
  _createClass(FontFaceObserver2, null, [{
    key: "getUserAgent",
    /**
     * @type {null|boolean}
     */
    /**
     * @type {null|boolean}
     */
    /**
     * @type {null|boolean}
     */
    /**
     * @type {null|boolean}
     */
    /**
     * @type {number}
     */
    /**
     * @return {string}
     */
    value: function getUserAgent() {
      return window.navigator.userAgent;
    }
    /**
     * @return {string}
     */
  }, {
    key: "getNavigatorVendor",
    value: function getNavigatorVendor() {
      return window.navigator.vendor;
    }
    /**
     * Returns true if this browser is WebKit and it has the fallback bug which is
     * present in WebKit 536.11 and earlier.
     *
     * @return {boolean}
     */
  }, {
    key: "hasWebKitFallbackBug",
    value: function hasWebKitFallbackBug() {
      if (FontFaceObserver2.HAS_WEBKIT_FALLBACK_BUG === null) {
        var match = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(FontFaceObserver2.getUserAgent());
        FontFaceObserver2.HAS_WEBKIT_FALLBACK_BUG = !!match && (parseInt(match[1], 10) < 536 || parseInt(match[1], 10) === 536 && parseInt(match[2], 10) <= 11);
      }
      return FontFaceObserver2.HAS_WEBKIT_FALLBACK_BUG;
    }
    /**
     * Returns true if the browser has the Safari 10 bugs. The native font load
     * API in Safari 10 has two bugs that cause the document.fonts.load and
     * FontFace.prototype.load methods to return promises that don't reliably get
     * settled.
     *
     * The bugs are described in more detail here:
     *  - https://bugs.webkit.org/show_bug.cgi?id=165037
     *  - https://bugs.webkit.org/show_bug.cgi?id=164902
     *
     * If the browser is made by Apple, and has native font loading support, it is
     * potentially affected. But the API was fixed around AppleWebKit version 603,
     * so any newer versions that that does not contain the bug.
     *
     * @return {boolean}
     */
  }, {
    key: "hasSafari10Bug",
    value: function hasSafari10Bug() {
      if (FontFaceObserver2.HAS_SAFARI_10_BUG === null) {
        if (FontFaceObserver2.supportsNativeFontLoading() && /Apple/.test(FontFaceObserver2.getNavigatorVendor())) {
          var match = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(FontFaceObserver2.getUserAgent());
          FontFaceObserver2.HAS_SAFARI_10_BUG = !!match && parseInt(match[1], 10) < 603;
        } else {
          FontFaceObserver2.HAS_SAFARI_10_BUG = false;
        }
      }
      return FontFaceObserver2.HAS_SAFARI_10_BUG;
    }
    /**
     * Returns true if the browser supports the native font loading API.
     *
     * @return {boolean}
     */
  }, {
    key: "supportsNativeFontLoading",
    value: function supportsNativeFontLoading() {
      if (FontFaceObserver2.SUPPORTS_NATIVE_FONT_LOADING === null) {
        FontFaceObserver2.SUPPORTS_NATIVE_FONT_LOADING = !!document["fonts"];
      }
      return FontFaceObserver2.SUPPORTS_NATIVE_FONT_LOADING;
    }
    /**
     * Returns true if the browser supports font-style in the font short-hand
     * syntax.
     *
     * @return {boolean}
     */
  }, {
    key: "supportStretch",
    value: function supportStretch() {
      if (FontFaceObserver2.SUPPORTS_STRETCH === null) {
        var div = document.createElement("div");
        try {
          div.style.font = "condensed 100px sans-serif";
        } catch (e) {
        }
        FontFaceObserver2.SUPPORTS_STRETCH = div.style.font !== "";
      }
      return FontFaceObserver2.SUPPORTS_STRETCH;
    }
    /**
     * @typedef {Object} Descriptors
     * @property {string|undefined} style
     * @property {string|undefined} weight
     * @property {string|undefined} stretch
     */
    /**
     *
     * @param {string} family font-family name (required)
     * @param {Descriptors} descriptors an object describing the variation
     * (optional). The object can contain `weight`, `style`, and `stretch`
     * properties. If a property is not present it will default to `normal`.
     */
  }]);
  function FontFaceObserver2(family) {
    var descriptors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, FontFaceObserver2);
    this.family = family;
    this.style = descriptors.style || "normal";
    this.weight = descriptors.weight || "normal";
    this.stretch = descriptors.stretch || "normal";
    return this;
  }
  _createClass(FontFaceObserver2, [{
    key: "load",
    value: function load(text, timeout) {
      var that = this;
      var testString = text || "BESbswy";
      var timeoutId = 0;
      var timeoutValue = timeout || FontFaceObserver2.DEFAULT_TIMEOUT;
      var start = that.getTime();
      return new Promise(function(resolve, reject) {
        if (FontFaceObserver2.supportsNativeFontLoading() && !FontFaceObserver2.hasSafari10Bug()) {
          var loader = new Promise(function(resolve2, reject2) {
            var check = function check2() {
              var now = that.getTime();
              if (now - start >= timeoutValue) {
                reject2(new Error("" + timeoutValue + "ms timeout exceeded"));
              } else {
                document.fonts.load(that.getStyle('"' + that["family"] + '"'), testString).then(function(fonts) {
                  if (fonts.length >= 1) {
                    resolve2();
                  } else {
                    setTimeout(check2, 25);
                  }
                }, reject2);
              }
            };
            check();
          });
          var timer = new Promise(function(resolve2, reject2) {
            timeoutId = setTimeout(function() {
              reject2(new Error("" + timeoutValue + "ms timeout exceeded"));
            }, timeoutValue);
          });
          Promise.race([timer, loader]).then(function() {
            clearTimeout(timeoutId);
            resolve(that);
          }, reject);
        } else {
          onReady(function() {
            var rulerA = new Ruler(testString);
            var rulerB = new Ruler(testString);
            var rulerC = new Ruler(testString);
            var widthA = -1;
            var widthB = -1;
            var widthC = -1;
            var fallbackWidthA = -1;
            var fallbackWidthB = -1;
            var fallbackWidthC = -1;
            var container = document.createElement("div");
            function removeContainer() {
              if (container.parentNode !== null) {
                container.parentNode.removeChild(container);
              }
            }
            function check() {
              if (widthA != -1 && widthB != -1 || widthA != -1 && widthC != -1 || widthB != -1 && widthC != -1) {
                if (widthA == widthB || widthA == widthC || widthB == widthC) {
                  if (FontFaceObserver2.hasWebKitFallbackBug()) {
                    if (widthA == fallbackWidthA && widthB == fallbackWidthA && widthC == fallbackWidthA || widthA == fallbackWidthB && widthB == fallbackWidthB && widthC == fallbackWidthB || widthA == fallbackWidthC && widthB == fallbackWidthC && widthC == fallbackWidthC) {
                      return;
                    }
                  }
                  removeContainer();
                  clearTimeout(timeoutId);
                  resolve(that);
                }
              }
            }
            container.dir = "ltr";
            rulerA.setFont(that.getStyle("sans-serif"));
            rulerB.setFont(that.getStyle("serif"));
            rulerC.setFont(that.getStyle("monospace"));
            container.appendChild(rulerA.getElement());
            container.appendChild(rulerB.getElement());
            container.appendChild(rulerC.getElement());
            document.body.appendChild(container);
            fallbackWidthA = rulerA.getWidth();
            fallbackWidthB = rulerB.getWidth();
            fallbackWidthC = rulerC.getWidth();
            function checkForTimeout() {
              var now = that.getTime();
              if (now - start >= timeoutValue) {
                removeContainer();
                reject(new Error("" + timeoutValue + "ms timeout exceeded"));
              } else {
                var hidden = document["hidden"];
                if (hidden === true || hidden === void 0) {
                  widthA = rulerA.getWidth();
                  widthB = rulerB.getWidth();
                  widthC = rulerC.getWidth();
                  check();
                }
                timeoutId = setTimeout(checkForTimeout, 50);
              }
            }
            checkForTimeout();
            rulerA.onResize(function(width) {
              widthA = width;
              check();
            });
            rulerA.setFont(that.getStyle('"' + that["family"] + '",sans-serif'));
            rulerB.onResize(function(width) {
              widthB = width;
              check();
            });
            rulerB.setFont(that.getStyle('"' + that["family"] + '",serif'));
            rulerC.onResize(function(width) {
              widthC = width;
              check();
            });
            rulerC.setFont(that.getStyle('"' + that["family"] + '",monospace'));
          });
        }
      });
    }
    /**
     * @private
     *
     * @param {string} family
     * @return {string}
     */
  }, {
    key: "getStyle",
    value: function getStyle(family) {
      return [this.style, this.weight, FontFaceObserver2.supportStretch() ? this.stretch : "", "100px", family].join(" ");
    }
    /**
     * @private
     *
     * @return {number}
     */
  }, {
    key: "getTime",
    value: function getTime() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  }]);
  return FontFaceObserver2;
}();
_defineProperty(FontFaceObserver, "Ruler", Ruler);
_defineProperty(FontFaceObserver, "HAS_WEBKIT_FALLBACK_BUG", null);
_defineProperty(FontFaceObserver, "HAS_SAFARI_10_BUG", null);
_defineProperty(FontFaceObserver, "SUPPORTS_STRETCH", null);
_defineProperty(FontFaceObserver, "SUPPORTS_NATIVE_FONT_LOADING", null);
_defineProperty(FontFaceObserver, "DEFAULT_TIMEOUT", 3e3);
var fontfaceobserver_esm_default = FontFaceObserver;

// node_modules/async-preloader/lib/types.js
var LoaderKey;
(function(LoaderKey2) {
  LoaderKey2["Json"] = "Json";
  LoaderKey2["ArrayBuffer"] = "ArrayBuffer";
  LoaderKey2["Blob"] = "Blob";
  LoaderKey2["FormData"] = "FormData";
  LoaderKey2["Text"] = "Text";
  LoaderKey2["Image"] = "Image";
  LoaderKey2["Video"] = "Video";
  LoaderKey2["Audio"] = "Audio";
  LoaderKey2["Xml"] = "Xml";
  LoaderKey2["Font"] = "Font";
})(LoaderKey || (LoaderKey = {}));

// node_modules/async-preloader/lib/index.js
var _a;
var isSafari = /^((?!chrome|android).)*safari/i.test((_a = globalThis.navigator) == null ? void 0 : _a.userAgent) === true;
var AsyncPreloader = class _AsyncPreloader {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
    this.defaultBodyMethod = "blob";
    this.defaultLoader = LoaderKey.Text;
    this.loadItems = async (items) => {
      return await Promise.all(items.map(this.loadItem));
    };
    this.loadItem = async (item) => {
      if (typeof item === "string")
        item = { src: item };
      const extension = _AsyncPreloader.getFileExtension(item.src || "");
      const loaderKey = item.loader || _AsyncPreloader.getLoaderKey(extension);
      const loadedItem = await this[`load` + loaderKey](item);
      this.items.set(item.id || item.src, loadedItem);
      return loadedItem;
    };
    this.loadManifest = async (src, key = "items") => {
      const loadedManifest = await this.loadJson({
        src
      });
      const items = _AsyncPreloader.getProp(loadedManifest, key);
      return await this.loadItems(items);
    };
    this.loadText = async (item) => {
      const response = await _AsyncPreloader.fetchItem(item);
      return await response.text();
    };
    this.loadJson = async (item) => {
      const response = await _AsyncPreloader.fetchItem(item);
      return await response.json();
    };
    this.loadArrayBuffer = async (item) => {
      const response = await _AsyncPreloader.fetchItem(item);
      return await response.arrayBuffer();
    };
    this.loadBlob = async (item) => {
      const response = await _AsyncPreloader.fetchItem(item);
      return await response.blob();
    };
    this.loadFormData = async (item) => {
      const response = await _AsyncPreloader.fetchItem(item);
      return await response.formData();
    };
    this.loadImage = async (item) => {
      const image = new Image();
      if (item.body) {
        const response = await _AsyncPreloader.fetchItem(item);
        const data = await response[item.body]();
        if (item.body !== "blob")
          return data;
        return await new Promise((resolve, reject) => {
          image.addEventListener("load", function load() {
            image.removeEventListener("load", load);
            resolve(image);
          });
          image.addEventListener("error", function error(event) {
            image.removeEventListener("error", error);
            reject(event);
          });
          image.src = URL.createObjectURL(data);
        });
      }
      image.src = item.src;
      if (!item.noDecode)
        await image.decode();
      return image;
    };
    this.loadVideo = async (item) => {
      const response = await _AsyncPreloader.fetchItem(item);
      const data = await response[item.body || this.defaultBodyMethod]();
      if (item.body)
        return data;
      const video = document.createElement("video");
      return await new Promise((resolve, reject) => {
        video.addEventListener("canplaythrough", function canplaythrough() {
          video.removeEventListener("canplaythrough", canplaythrough);
          resolve(video);
        });
        video.addEventListener("error", function error(event) {
          video.removeEventListener("error", error);
          reject(event);
        });
        try {
          if (isSafari)
            throw "";
          video.srcObject = data;
        } catch (error) {
          video.src = URL.createObjectURL(data);
        }
        video.load();
      });
    };
    this.loadAudio = async (item) => {
      const response = await _AsyncPreloader.fetchItem(item);
      const data = await response[item.body || this.defaultBodyMethod]();
      if (item.body)
        return data;
      const audio = document.createElement("audio");
      audio.autoplay = false;
      audio.preload = "auto";
      return await new Promise((resolve, reject) => {
        audio.addEventListener("canplaythrough", function canplaythrough() {
          audio.removeEventListener("canplaythrough", canplaythrough);
          resolve(audio);
        });
        audio.addEventListener("error", function error(event) {
          audio.removeEventListener("error", error);
          reject(event);
        });
        try {
          if (isSafari)
            throw "";
          audio.srcObject = data;
        } catch (error) {
          audio.src = URL.createObjectURL(data);
        }
        audio.load();
      });
    };
    this.loadXml = async (item) => {
      if (!item.mimeType) {
        const extension = _AsyncPreloader.getFileExtension(item.src);
        item = {
          ...item,
          mimeType: _AsyncPreloader.getMimeType(LoaderKey.Xml, extension)
        };
      }
      if (!_AsyncPreloader.domParser) {
        throw new Error("DomParser is not supported.");
      }
      const response = await _AsyncPreloader.fetchItem(item);
      const data = await response.text();
      return _AsyncPreloader.domParser.parseFromString(data, item.mimeType);
    };
    this.loadFont = async (item) => {
      const fontName = item.id || _AsyncPreloader.getFileName(item.src);
      const options = item.fontOptions || {};
      if (!item.src) {
        const font2 = new fontfaceobserver_esm_default(fontName, options.variant || {});
        await font2.load(options.testString, options.timeout);
        return fontName;
      }
      const source = item.body === "arrayBuffer" ? await this.loadArrayBuffer({ src: item.src }) : `url(${item.src})`;
      const font = new FontFace(fontName, source, options.descriptors);
      return await font.load().then((font2) => {
        document.fonts.add(font2);
        return font2;
      });
    };
  }
  // Utils
  /**
   * Fetch wrapper for LoadItem
   *
   * @param item Item to fetch
   * @returns Fetch response
   */
  static fetchItem(item) {
    return fetch(item.src, item.options || {});
  }
  /**
   * Get an object property by its path in the form 'a[0].b.c' or ['a', '0', 'b', 'c'].
   * Similar to [lodash.get](https://lodash.com/docs/4.17.5#get).
   *
   * @param object Object with nested properties
   * @param path Path to the desired property
   * @returns The returned object property
   */
  static getProp(object, path) {
    const p = Array.isArray(path) ? path : path.split(".").filter((index) => index.length);
    if (!p.length)
      return object;
    return _AsyncPreloader.getProp(object[p.shift()], p);
  }
  /**
   * Get file extension
   *
   * @param path
   * @returns
   */
  static getFileExtension(path) {
    return ((path == null ? void 0 : path.match(/[^\\/]\.([^.\\/]+)$/)) || [null]).pop();
  }
  /**
   * Get file base name
   *
   * @param path
   * @returns
   */
  static getFileBaseName(path) {
    return path.split(/[\\/]/).pop();
  }
  /**
   * Get file name
   *
   * @param path
   * @returns
   */
  static getFileName(path) {
    return _AsyncPreloader.getFileBaseName(path).split(".").slice(0, -1).join(".") || path;
  }
  /**
   * Retrieve loader key from extension (when the loader option isn't specified in the LoadItem)
   *
   * @param extension
   * @returns
   */
  static getLoaderKey(extension) {
    const loader = Array.from(_AsyncPreloader.loaders).find((loader2) => loader2[1].extensions.includes(extension));
    return loader ? loader[0] : LoaderKey.Text;
  }
  /**
   * Retrieve mime type from extension
   *
   * @param loaderKey
   * @param extension
   * @returns
   */
  static getMimeType(loaderKey, extension) {
    const loader = _AsyncPreloader.loaders.get(loaderKey);
    return loader.mimeType[extension] || loader.defaultMimeType;
  }
};
AsyncPreloader.loaders = (/* @__PURE__ */ new Map()).set(LoaderKey.Text, { extensions: ["txt"] }).set(LoaderKey.Json, { extensions: ["json"] }).set(LoaderKey.Image, { extensions: ["jpeg", "jpg", "gif", "png", "webp"] }).set(LoaderKey.Video, { extensions: ["webm", "ogg", "mp4"] }).set(LoaderKey.Audio, { extensions: ["webm", "ogg", "mp3", "wav", "flac"] }).set(LoaderKey.Xml, {
  extensions: ["xml", "svg", "html"],
  mimeType: {
    xml: "text/xml",
    svg: "image/svg+xml",
    html: "text/html"
  },
  defaultMimeType: "text/xml"
}).set(LoaderKey.Font, {
  extensions: ["woff2", "woff", "ttf", "otf", "eot"]
});
AsyncPreloader.domParser = typeof DOMParser !== "undefined" && new DOMParser();
var AsyncPreloaderInstance = new AsyncPreloader();
var lib_default = AsyncPreloaderInstance;
export {
  AsyncPreloader,
  lib_default as default
};
//# sourceMappingURL=async-preloader.js.map
